/*
 * Amber API Server
 * Boon Logic Amber API server
 *
 * The version of the OpenAPI document: 2.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.boonamber.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import org.boonamber.client.model.FeatureConfig;
import org.boonamber.client.model.TrainingConfig;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import org.boonamber.client.JSON;

/**
 * Config
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class Config {
  public static final String SERIALIZED_NAME_STREAMING_WINDOW = "streamingWindow";
  @SerializedName(SERIALIZED_NAME_STREAMING_WINDOW)
  private Integer streamingWindow;

  public static final String SERIALIZED_NAME_PERCENT_VARIATION = "percentVariation";
  @SerializedName(SERIALIZED_NAME_PERCENT_VARIATION)
  private Float percentVariation;

  public static final String SERIALIZED_NAME_FEATURES = "features";
  @SerializedName(SERIALIZED_NAME_FEATURES)
  private List<FeatureConfig> features = new ArrayList<>();

  public static final String SERIALIZED_NAME_TRAINING = "training";
  @SerializedName(SERIALIZED_NAME_TRAINING)
  private TrainingConfig training;

  public Config() {
  }

  public Config streamingWindow(Integer streamingWindow) {
    
    this.streamingWindow = streamingWindow;
    return this;
  }

   /**
   * Number of recent input _vectors_ concatenated together to make up a full input _pattern_ presented to the model for inference.  Let &#x60;featureCount&#x60; be the configured number of features. The model consumes data sequentially in steps of size &#x60;featureCount&#x60;. Each time it receives &#x60;featureCount&#x60; data values, &#x60;featureCount&#x60; input values are consumed and concatenated together to form an input _vector_. This input vector is then concatenated with zero or more past input vectors to form an input _pattern_. The input _pattern_ is the true data vector inferenced by the model at each step. Configuring the &#x60;streamingWindow&#x60; greater than 1 allows a model to identify patterns in vectors that change over time.  If monitoring a single timeseries signal, the model should be configured with just one feature. In that case the input vector has length 1, and &#x60;streamingWindow&#x60; determines the length of a moving window over past samples which is the input pattern to the model for each new sample. For example, a model configured with one feature and a &#x60;streamingWindow&#x60; of 25 will concatenate together and inference the 25 most recent data values for each new value consumed.  If monitoring instantaneous readings from several sensors jointly, each sensor should be associated with one feature in the configuration. In this case &#x60;streamingWindow&#x60; is usually set to 1 so that the input pattern is just the current vector of readings. For example, a model configured with 5 features and a &#x60;streamingWindow&#x60; of 1 will consume 5 values at a time and inference those 5 values as a pattern of length 5. If the &#x60;streamingWindow&#x60; were 2, the model would still consume 5 values at a time, but its input pattern would contain the last 10 samples.
   * minimum: 1
   * @return streamingWindow
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "Number of recent input _vectors_ concatenated together to make up a full input _pattern_ presented to the model for inference.  Let `featureCount` be the configured number of features. The model consumes data sequentially in steps of size `featureCount`. Each time it receives `featureCount` data values, `featureCount` input values are consumed and concatenated together to form an input _vector_. This input vector is then concatenated with zero or more past input vectors to form an input _pattern_. The input _pattern_ is the true data vector inferenced by the model at each step. Configuring the `streamingWindow` greater than 1 allows a model to identify patterns in vectors that change over time.  If monitoring a single timeseries signal, the model should be configured with just one feature. In that case the input vector has length 1, and `streamingWindow` determines the length of a moving window over past samples which is the input pattern to the model for each new sample. For example, a model configured with one feature and a `streamingWindow` of 25 will concatenate together and inference the 25 most recent data values for each new value consumed.  If monitoring instantaneous readings from several sensors jointly, each sensor should be associated with one feature in the configuration. In this case `streamingWindow` is usually set to 1 so that the input pattern is just the current vector of readings. For example, a model configured with 5 features and a `streamingWindow` of 1 will consume 5 values at a time and inference those 5 values as a pattern of length 5. If the `streamingWindow` were 2, the model would still consume 5 values at a time, but its input pattern would contain the last 10 samples.")

  public Integer getStreamingWindow() {
    return streamingWindow;
  }


  public void setStreamingWindow(Integer streamingWindow) {
    this.streamingWindow = streamingWindow;
  }


  public Config percentVariation(Float percentVariation) {
    
    this.percentVariation = percentVariation;
    return this;
  }

   /**
   * Granularity of the underlying cluster model used for anomaly detection. This is a number between 0.01 and 0.20 which is the distance threshold used to determine whether a pattern should be assigned to an existing cluster or create a new cluster of its own. All things held equal, a small &#x60;percentVariation&#x60; will segment a dataset into many clusters while a larger &#x60;percentVariation&#x60; will segment the dataset into fewer clusters.  &#x60;percentVariation&#x60; can be left unset if it is not known at configuration time. In that case, data collected during the &#x60;Buffering&#x60; stage will be used to infer an optimal &#x60;percentVariation&#x60; during the &#x60;Autotuning&#x60; stage and it will be set to the autotuned value at the start of &#x60;Learning&#x60;.
   * minimum: 0.01
   * maximum: 0.2
   * @return percentVariation
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Granularity of the underlying cluster model used for anomaly detection. This is a number between 0.01 and 0.20 which is the distance threshold used to determine whether a pattern should be assigned to an existing cluster or create a new cluster of its own. All things held equal, a small `percentVariation` will segment a dataset into many clusters while a larger `percentVariation` will segment the dataset into fewer clusters.  `percentVariation` can be left unset if it is not known at configuration time. In that case, data collected during the `Buffering` stage will be used to infer an optimal `percentVariation` during the `Autotuning` stage and it will be set to the autotuned value at the start of `Learning`.")

  public Float getPercentVariation() {
    return percentVariation;
  }


  public void setPercentVariation(Float percentVariation) {
    this.percentVariation = percentVariation;
  }


  public Config features(List<FeatureConfig> features) {
    
    this.features = features;
    return this;
  }

  public Config addFeaturesItem(FeatureConfig featuresItem) {
    this.features.add(featuresItem);
    return this;
  }

   /**
   * Get features
   * @return features
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "")

  public List<FeatureConfig> getFeatures() {
    return features;
  }


  public void setFeatures(List<FeatureConfig> features) {
    this.features = features;
  }


  public Config training(TrainingConfig training) {
    
    this.training = training;
    return this;
  }

   /**
   * Get training
   * @return training
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public TrainingConfig getTraining() {
    return training;
  }


  public void setTraining(TrainingConfig training) {
    this.training = training;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Config config = (Config) o;
    return Objects.equals(this.streamingWindow, config.streamingWindow) &&
        Objects.equals(this.percentVariation, config.percentVariation) &&
        Objects.equals(this.features, config.features) &&
        Objects.equals(this.training, config.training);
  }

  @Override
  public int hashCode() {
    return Objects.hash(streamingWindow, percentVariation, features, training);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Config {\n");
    sb.append("    streamingWindow: ").append(toIndentedString(streamingWindow)).append("\n");
    sb.append("    percentVariation: ").append(toIndentedString(percentVariation)).append("\n");
    sb.append("    features: ").append(toIndentedString(features)).append("\n");
    sb.append("    training: ").append(toIndentedString(training)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("streamingWindow");
    openapiFields.add("percentVariation");
    openapiFields.add("features");
    openapiFields.add("training");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("streamingWindow");
    openapiRequiredFields.add("features");
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to Config
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!Config.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Config is not found in the empty JSON string", Config.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!Config.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Config` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : Config.openapiRequiredFields) {
        if (jsonObj.get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonObj.toString()));
        }
      }
      // ensure the json data is an array
      if (!jsonObj.get("features").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `features` to be an array in the JSON string but got `%s`", jsonObj.get("features").toString()));
      }

      JsonArray jsonArrayfeatures = jsonObj.getAsJsonArray("features");
      // validate the required field `features` (array)
      for (int i = 0; i < jsonArrayfeatures.size(); i++) {
        FeatureConfig.validateJsonObject(jsonArrayfeatures.get(i).getAsJsonObject());
      };
      // validate the optional field `training`
      if (jsonObj.get("training") != null && !jsonObj.get("training").isJsonNull()) {
        TrainingConfig.validateJsonObject(jsonObj.getAsJsonObject("training"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Config.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Config' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Config> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Config.class));

       return (TypeAdapter<T>) new TypeAdapter<Config>() {
           @Override
           public void write(JsonWriter out, Config value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Config read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of Config given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of Config
  * @throws IOException if the JSON string is invalid with respect to Config
  */
  public static Config fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Config.class);
  }

 /**
  * Convert an instance of Config to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

