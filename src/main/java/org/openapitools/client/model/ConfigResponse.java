/*
 * Amber API Server
 * Boon Logic Amber API server
 *
 * The version of the OpenAPI document: 2.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import org.openapitools.client.model.FeatureConfigResponse;
import org.openapitools.client.model.PercentVariationResponse;
import org.openapitools.client.model.TrainingConfig;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * ConfigResponse
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2023-01-13T15:06:47.098836-06:00[America/Chicago]")
public class ConfigResponse {
  public static final String SERIALIZED_NAME_STREAMING_WINDOW = "streamingWindow";
  @SerializedName(SERIALIZED_NAME_STREAMING_WINDOW)
  private Integer streamingWindow;

  public static final String SERIALIZED_NAME_PERCENT_VARIATION = "percentVariation";
  @SerializedName(SERIALIZED_NAME_PERCENT_VARIATION)
  private PercentVariationResponse percentVariation;

  public static final String SERIALIZED_NAME_FEATURES = "features";
  @SerializedName(SERIALIZED_NAME_FEATURES)
  private List<FeatureConfigResponse> features = null;

  public static final String SERIALIZED_NAME_TRAINING = "training";
  @SerializedName(SERIALIZED_NAME_TRAINING)
  private TrainingConfig training;

  public ConfigResponse() {
  }

  public ConfigResponse streamingWindow(Integer streamingWindow) {
    
    this.streamingWindow = streamingWindow;
    return this;
  }

   /**
   * Number of recent input _vectors_ concatenated together to make up a full input _pattern_ presented to the model for inference.  Let &#x60;featureCount&#x60; be the configured number of features. The model consumes data sequentially in steps of size &#x60;featureCount&#x60;. Each time it receives &#x60;featureCount&#x60; data values, &#x60;featureCount&#x60; input values are consumed and concatenated together to form an input _vector_. This input vector is then concatenated with zero or more past input vectors to form an input _pattern_. The input _pattern_ is the true data vector inferenced by the model at each step. Configuring the &#x60;streamingWindow&#x60; greater than 1 allows a model to identify patterns in vectors that change over time.  If monitoring a single timeseries signal, the model should be configured with just one feature. In that case the input vector has length 1, and &#x60;streamingWindow&#x60; determines the length of a moving window over past samples which is the input pattern to the model for each new sample. For example, a model configured with one feature and a &#x60;streamingWindow&#x60; of 25 will concatenate together and inference the 25 most recent data values for each new value consumed.  If monitoring instantaneous readings from several sensors jointly, each sensor should be associated with one feature in the configuration. In this case &#x60;streamingWindow&#x60; is usually set to 1 so that the input pattern is just the current vector of readings. For example, a model configured with 5 features and a &#x60;streamingWindow&#x60; of 1 will consume 5 values at a time and inference those 5 values as a pattern of length 5. If the &#x60;streamingWindow&#x60; were 2, the model would still consume 5 values at a time, but its input pattern would contain the last 10 samples.
   * minimum: 1
   * @return streamingWindow
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Number of recent input _vectors_ concatenated together to make up a full input _pattern_ presented to the model for inference.  Let `featureCount` be the configured number of features. The model consumes data sequentially in steps of size `featureCount`. Each time it receives `featureCount` data values, `featureCount` input values are consumed and concatenated together to form an input _vector_. This input vector is then concatenated with zero or more past input vectors to form an input _pattern_. The input _pattern_ is the true data vector inferenced by the model at each step. Configuring the `streamingWindow` greater than 1 allows a model to identify patterns in vectors that change over time.  If monitoring a single timeseries signal, the model should be configured with just one feature. In that case the input vector has length 1, and `streamingWindow` determines the length of a moving window over past samples which is the input pattern to the model for each new sample. For example, a model configured with one feature and a `streamingWindow` of 25 will concatenate together and inference the 25 most recent data values for each new value consumed.  If monitoring instantaneous readings from several sensors jointly, each sensor should be associated with one feature in the configuration. In this case `streamingWindow` is usually set to 1 so that the input pattern is just the current vector of readings. For example, a model configured with 5 features and a `streamingWindow` of 1 will consume 5 values at a time and inference those 5 values as a pattern of length 5. If the `streamingWindow` were 2, the model would still consume 5 values at a time, but its input pattern would contain the last 10 samples.")

  public Integer getStreamingWindow() {
    return streamingWindow;
  }


  public void setStreamingWindow(Integer streamingWindow) {
    this.streamingWindow = streamingWindow;
  }


  public ConfigResponse percentVariation(PercentVariationResponse percentVariation) {
    
    this.percentVariation = percentVariation;
    return this;
  }

   /**
   * Get percentVariation
   * @return percentVariation
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public PercentVariationResponse getPercentVariation() {
    return percentVariation;
  }


  public void setPercentVariation(PercentVariationResponse percentVariation) {
    this.percentVariation = percentVariation;
  }


  public ConfigResponse features(List<FeatureConfigResponse> features) {
    
    this.features = features;
    return this;
  }

  public ConfigResponse addFeaturesItem(FeatureConfigResponse featuresItem) {
    if (this.features == null) {
      this.features = new ArrayList<>();
    }
    this.features.add(featuresItem);
    return this;
  }

   /**
   * Get features
   * @return features
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public List<FeatureConfigResponse> getFeatures() {
    return features;
  }


  public void setFeatures(List<FeatureConfigResponse> features) {
    this.features = features;
  }


  public ConfigResponse training(TrainingConfig training) {
    
    this.training = training;
    return this;
  }

   /**
   * Get training
   * @return training
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public TrainingConfig getTraining() {
    return training;
  }


  public void setTraining(TrainingConfig training) {
    this.training = training;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ConfigResponse configResponse = (ConfigResponse) o;
    return Objects.equals(this.streamingWindow, configResponse.streamingWindow) &&
        Objects.equals(this.percentVariation, configResponse.percentVariation) &&
        Objects.equals(this.features, configResponse.features) &&
        Objects.equals(this.training, configResponse.training);
  }

  @Override
  public int hashCode() {
    return Objects.hash(streamingWindow, percentVariation, features, training);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ConfigResponse {\n");
    sb.append("    streamingWindow: ").append(toIndentedString(streamingWindow)).append("\n");
    sb.append("    percentVariation: ").append(toIndentedString(percentVariation)).append("\n");
    sb.append("    features: ").append(toIndentedString(features)).append("\n");
    sb.append("    training: ").append(toIndentedString(training)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("streamingWindow");
    openapiFields.add("percentVariation");
    openapiFields.add("features");
    openapiFields.add("training");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to ConfigResponse
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!ConfigResponse.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ConfigResponse is not found in the empty JSON string", ConfigResponse.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!ConfigResponse.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ConfigResponse` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }
      // validate the optional field `percentVariation`
      if (jsonObj.get("percentVariation") != null && !jsonObj.get("percentVariation").isJsonNull()) {
        PercentVariationResponse.validateJsonObject(jsonObj.getAsJsonObject("percentVariation"));
      }
      if (jsonObj.get("features") != null && !jsonObj.get("features").isJsonNull()) {
        JsonArray jsonArrayfeatures = jsonObj.getAsJsonArray("features");
        if (jsonArrayfeatures != null) {
          // ensure the json data is an array
          if (!jsonObj.get("features").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `features` to be an array in the JSON string but got `%s`", jsonObj.get("features").toString()));
          }

          // validate the optional field `features` (array)
          for (int i = 0; i < jsonArrayfeatures.size(); i++) {
            FeatureConfigResponse.validateJsonObject(jsonArrayfeatures.get(i).getAsJsonObject());
          };
        }
      }
      // validate the optional field `training`
      if (jsonObj.get("training") != null && !jsonObj.get("training").isJsonNull()) {
        TrainingConfig.validateJsonObject(jsonObj.getAsJsonObject("training"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ConfigResponse.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ConfigResponse' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ConfigResponse> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ConfigResponse.class));

       return (TypeAdapter<T>) new TypeAdapter<ConfigResponse>() {
           @Override
           public void write(JsonWriter out, ConfigResponse value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ConfigResponse read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of ConfigResponse given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of ConfigResponse
  * @throws IOException if the JSON string is invalid with respect to ConfigResponse
  */
  public static ConfigResponse fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ConfigResponse.class);
  }

 /**
  * Convert an instance of ConfigResponse to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

